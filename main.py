import os
import numpy as np
import pandas as pd
import sqlite3
import csv
import datetime
import json

import _email, bucket
from mapping import TranslationMap
from utils.utils import generate_datetime, hash_string
from expenses import generate_expense, generate_orders, generate_order_details, get_dataset
from legacy_names import gen_name

# GDPR notice: this program can potentially generate real personal data
# Make sure anonymize is TRUE or manually check all generated rows before making anything public

anonymize = False

# Adjust ammount of people / entries to generate
rows = 1000

# Export settings
export_csv = True
export_excel = False
export_sql = False

export_path = 'Exports'
file_name ='tpme_export'

def quick_mail(n, export_as='csv', export_path=export_path, verbose=True):
    """
    Quickly generate n email addresses and export them using the export_manager.

    Parameters:
    - n (int): Number of email addresses to generate.
    - export_as (str, optional): Format in which to export the email addresses (default is 'csv').
    - export_path (str, optional): File path for exporting the generated email addresses (default is export_path).
    - verbose (bool, optional): If True, print progress messages; if False, suppress messages (default is True).

    """

    samples = [_email.gen_email() for i in range(n)]

    if export_path:
        export_manager(samples, export_as, export_path, verbose)

    return samples

def quick_name(n):
    """
    Quickly generates and returns names.
    """

    samples = [gen_name() for i in range(n)]

    return samples


def quick_expenses(n_people=12,
                   n_expenses=200,
                   keyword=None,
                   category=None,
                   timeframe=None):
    """
    Quickly generate synthetic expenses table.
    """

    people = quick_name(n_people)

    expenses_list = []

    for _ in range(n_expenses):
        expense = generate_expense(keyword, category)

        expense['Person'] = np.random.choice(people)
        expenses_list.append(expense)

    expenses_df = pd.DataFrame(expenses_list)

    return expenses_df


def export_manager(data, export_as='csv', export_path=export_path, verbose=True, index=False):

    # Default dir for exporting
    os.makedirs(export_path, exist_ok=True)

    export_as = export_as.lower()

    file_name = f"TPME_{datetime.datetime.now()}"
    header = "Generated by TPME - https://github.com/wlinds/tpme"

    if isinstance(data, list):

        # if export_as == 'csv':
        #     csv_file_path = os.path.join(export_path, f"{file_name}.csv")
        #     with open(csv_file_path, "w", newline="") as csv_file:
        #         csv_writer = csv.writer(csv_file)
        #         csv_writer.writerow([{header}])
        #         for sample in data:
        #             csv_writer.writerow([sample])

        if export_as == 'csv':
            csv_file_path = os.path.join(export_path, f"{file_name}.csv")
            with open(csv_file_path, "w") as csv_file:
                csv_writer = csv.writer(csv_file)
                # Write header directly
                csv_writer.writerow([header])
                # Write each data point without extra list wrapping
                for sample in data:
                    csv_writer.writerow(sample)

        elif export_as == 'json':
            json_file_path = os.path.join(export_path, f"{file_name}.json")
            with open(json_file_path, "w") as json_file:
                json.dump({"emails": data}, json_file, indent=2)

    elif isinstance(data, pd.DataFrame):

        # df = value_mapper(data)
    
        if export_as == 'excel' or export_as == 'xlsx':
            pd.DataFrame.to_excel(data, f'{export_path}/{file_name}.xlsx',index=index)

        elif export_as == 'sql':
            db_path = f'{export_path}/{file_name}.db'
            con = sqlite3.connect(db_path)
            df.to_sql('People', con=con, if_exists='replace')

        elif export_as == 'csv':
            pd.DataFrame.to_csv(data, f'{export_path}/{file_name}.csv,', index=index)

    if verbose:
        print(f'Saved as {export_as}: {export_path}/{file_name}')


def gen_gender(female=0.5, male=0.5, nb=0.02):
    if anonymize:
        return 3
    if np.random.uniform() < 1 - nb:
        return np.random.choice([1, 2], p=[1-female, 1-male])
    else:
        return 3

def gen_age(mean=42, std=20, lower_lim=15, upper_lim=100):
  "Normal distribution, default mean of 42 and standard deviation of 20"

  # age = int(np.random.normal(loc=mean, scale=std))
  # while age <= lower_lim or age >= upper_lim:
  #     age = int(np.random.normal(loc=mean, scale=std))
  # return age

  # Probably a better solution
  age = int(np.random.normal(loc=mean, scale=std))
  age = max(age, lower_lim)
  age = min(age, upper_lim)
  return age

#TODO: Check correlation with age for civilstånd, utbildningsnivå etc.

def gen_marital(age):
  if age < 18: return 6
  if age <= 25: np.random.choice([1, 5, 6], p=[0.01, 0.98, 0.01])
  if age >= 50: np.random.choice([1, 2, 3, 4, 5, 6,], p=[0.5, 0.05, 0.15, 0.15, 0.10, 0.05])
  return np.random.choice([1, 2, 3, 4, 5, 6], p=[0.35, 0.02, 0.09, 0.04, 0.47, 0.03])
  # TODO: age should clearly be a used more thoughtful

def gen_education(age):
  if age <= 17: return 1 # Grundskolenivå garanterad för age <= 16
  elif age in range(18,19): return np.random.randint(1, high=3) # Slumpar studentexamen för 18-19 år
  elif age >= 19: return np.random.choice([1, 2, 3, 4, 5, 6], p=[0.01, 0.01, 0.26, 0.21, 0.270, 0.24])
  # allt annat random TODO: implement probability for each age

def gen_occupation(age):
  if age >= 66: return 5 # Garanterar pension över 66
  elif age >= 60: return np.random.choice([1, 4, 5, 6]) # Möjlig pension över 60, ej möjliga studier
  elif age <= 17: return 2 # Garanterar studier under 17
  elif age >= 18 or age <= 30: return np.random.choice([1, 2, 3, 4], p=[0.25, 0.65, 0.05, 0.05]) #Högre sannolikhet att vara student
  return np.random.choice([1, 2, 3, 4, 5, 6], p=[0.7, 0.1, 0.088, 0.086, 0.0, 0.02]) # Speglar arbetslöshet och sjukskrivning i sverige 2022

def gen_accommodation():
  return np.random.choice([1, 2, 3, 4, 5], p=[0.25, 0.25, 0.49, 0.005, 0.005])
  # VERY ROUGH estimate, probably not even remotely close to actual distribution
  # TODO: add parameters for probability from age and other stuff

def gen_living_with(age, civilstånd):
  if age <= 17: return 4 # Garanterar boende med förälder under 17
  if age >= 31 or age <= 50: return np.random.choice([1, 2, 3, 4, 5, 6], p=[0.2, 0.1, 0.2, 0.002, 0.002, 0.496]) # ökad sannolikhet att bo med familj i åldersspann 31-50
  if civilstånd == 2 or 3: return np.random.choice([1, 3, 5], p=[0.98, 0.01, 0.01])
  return np.random.choice([1, 2, 3, 5, 6], p=[0.362, 0.4, 0.02, 0.1, 0.118]) # ensamboende speglar scb 2019, resten lekmannaestimering

## ------- Health  ------- ##

def gen_vardagstillfredsställelse():
  "Normal distribution with mean 3 and std 1.6"
  val = int(np.random.normal(loc=3, scale=1.6))
  while val < 1 or val > 5: # prevent values out of range
    val = int(np.random.normal(loc=3, scale=1.6))
  return val
  #TODO: find probability from other parameters such as living situation and age

def gen_health(mean=3, std=1, skewness=0):
    values = np.arange(1, 6)
    z_scores = (values - mean) / std
    probabilities = np.exp(-0.5 * z_scores**2) * (1 + skewness * z_scores)
    probabilities /= np.sum(probabilities)

    # ensure that all probabilities are non-negative
    if np.any(probabilities < 0):
        probabilities[probabilities < 0] = 0
        probabilities /= np.sum(probabilities)
    else:
        probabilities /= np.sum(probabilities)

    return np.random.choice(values, p=probabilities)


def gen_phone(anonymize=False):
  # challenge# 1: needs to be unique
  # for now it will have a probability of 2.474631929433396e-07 to be duplicare

  # Swedish phone# TODO add other 
  a = str(np.random.choice([70, 72, 73, 76, 79]))
  b = np.random.randint(100, high=999)
  c = np.random.randint(100, high=999)

  if anonymize:
    a = 'XX'

  def add_zero(n):
      if n < 10: n = '00' + str(n)
      elif n < 100: n = '0' + str(n)
      return str(n)

  phone = str(0) + a + str(np.random.randint(0,9)) + add_zero(b) + add_zero(c)
  return phone


def gen_customerID():
    random_number = np.random.randint(100000, 999999)
    user_id = f'U{random_number}'
    return user_id

def gen_address():
    street_names = []
    with open('Data/datasets/ssn.csv', 'r', newline='', encoding='utf-8') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            street_names.append(row['Street Name'])

    return np.random.choice(street_names) + " " + str(np.random.randint(1,30))

def gen_postal():
    first_part = np.random.randint(100, 999)
    second_part = np.random.randint(10, 99)
    postal_code = f"{first_part} {second_part}"
    return postal_code

def gen_country():
    return 'Sweden'

def gen_city():
    return np.random.choice(['Göteborg', 'Stockholm', 'Malmö'])


class PersonGenerator:
    def __init__(self, anonymize=True):
        self.anonymize = anonymize
        
    def generate_person(self, 
    
        dist_gender = {'female': 0.5, 'male': 0.5, 'nb': 0.02},
        dist_age = {'mean': 42, 'std': 20, 'lower_lim': 15, 'upper_lim': 100},
        dist_health = {'mean': 3, 'std': 1, 'skewness': 0},
        name_length = {'min_len': 10, 'max_len': 12}

        ):

        # Just ints
        age = gen_age(**dist_age)
        phone = gen_phone()
        gendr = gen_gender(**dist_gender)
        civil = gen_marital(age)
        utbil = gen_education(age)
        syssl = gen_occupation(age)
        boend = gen_accommodation()
        bormd = gen_living_with(age, civil)
        vardt = gen_vardagstillfredsställelse()
        hälsa = gen_health(**dist_health)

        customer_id = gen_customerID()

        address = gen_address()
        postal = gen_postal()
        city = gen_city()
        country = gen_country()

        # TODO: Finisish tokenization
        name = gen_name(gendr, **name_length)

        mail = _email.gen_email(name, age, self.anonymize)
        _psw = _email.gen_psw(name, age, self.anonymize)

        # TODO fix this clusterfuck also rename to english
        return (age,name,mail,_psw,phone,gendr,civil,utbil,syssl,boend,bormd,vardt,hälsa, customer_id, address, postal, city, country)

    def customer_generation(self, 
    
        dist_gender = {'female': 0.5, 'male': 0.5, 'nb': 0.02},
        dist_age = {'mean': 42, 'std': 20, 'lower_lim': 15, 'upper_lim': 100},
        name_length = {'min_len': 10, 'max_len': 12}

        ):
        gendr = gen_gender(**dist_gender)
        age = gen_age(**dist_age)
        phone = gen_phone(anonymize=True)
        customer_id = gen_customerID()
        address = gen_address()
        postal = gen_postal()
        city = gen_city()
        country = gen_country()
        name = gen_name(gendr, **name_length)
        mail = _email.gen_email(name, age, anonymize=True)
        _psw = _email.gen_psw(name, age, self.anonymize)

        return (customer_id,name,mail,_psw,phone,address,postal,city,country)



def value_mapper(person_list, language='english', anonymize=False, is_customer=False):
    tm = TranslationMap(language=language)

    if isinstance(person_list, tuple):
        person_list = [person_list]
    
    if is_customer:
        df = pd.DataFrame(person_list, columns=[tm.column_names[13], tm.column_names[1], tm.column_names[2], tm.column_names[3], tm.column_names[4], tm.column_names[14], tm.column_names[15], tm.column_names[16], tm.column_names[17]])

        return df

    df = pd.DataFrame(person_list, columns=[tm.column_names])

    df['Gender'] = df.apply(lambda row: tm.get_translation('Gender', row['Gender']), axis=1)
    df['Marital Status'] = df.apply(lambda row: tm.get_translation('Marital Status', row['Marital Status']), axis=1)
    df['Education'] = df.apply(lambda row: tm.get_translation('Education', row['Education']), axis=1)
    df['Occupation'] = df.apply(lambda row: tm.get_translation('Occupation', row['Occupation']), axis=1)
    df['Accommodation'] = df.apply(lambda row: tm.get_translation('Accommodation', row['Accommodation']), axis=1)
    df['Living with'] = df.apply(lambda row: tm.get_translation('Living with', row['Living with']), axis=1)

    if anonymize:
        print('Hashing selected columns')
        df['Name'] = df['Name'].apply(hash_string, end=8)

    if language == 'swedish':
        df.columns = [tm.column_names_swe]

    return df


if __name__ == '__main__':
    # Create instance of person class
    # pg = PersonGenerator(anonymize=anonymize)
    # person_list = [pg.generate_person() for n in range(rows)]

    # df = value_mapper(person_list)
    # print(df)

    # export_manager(df, export_as='csv')
    # export_manager(df, export_as='json')
    # export_manager(df, export_as='excel')
    # export_manager(df, export_as='sql')

    # print(quick_mail(1000, export_as='csv'))
    # print(quick_mail(1000, export_as='json'))
    # print(quick_mail(1000, export_as='excel'))
    # print(quick_mail(1000, export_as='sql'))


    # print(generate_expense())
    # print(quick_expenses())

    # pg = PersonGenerator(anonymize=False)
    # person_list = [pg.generate_person(dist_age={'mean': 10, 'std': 0, 'lower_lim': 0, 'upper_lim': 10}) for n in range(10)]
    # df = value_mapper(person_list)
    # print(df)

    # person = pg.customer_generation()

    # person_list = [pg.customer_generation(dist_age={'mean': 10, 'std': 0, 'lower_lim': 0, 'upper_lim': 10}) for n in range(50)]

    # print(type(person_list))
    # print(person_list)

    # df = value_mapper(person_list, is_customer=True)
    # df = df.drop(['Password'], axis=1)
    # print(df)

    # export_manager(df, export_as='csv')

    # print(generate_expense(keyword="Dog Treats", search_by='title', exclude_word=['backpack', 'bag', 'transport']))



    # df = pd.read_csv('Exports/AppFarm.csv')

    # products = get_dataset(custom_path='Data/product.csv')
    # orders = get_dataset(custom_path='Data/export_data (1).csv')
    # print(products)
    # print(orders)

    # order_details = generate_order_details(orders, custom_path='Data/products.csv')
    # print(order_details)

    # export_manager(order_details)



    # orders, order_details = generate_orders(df, 3, start_at=512)
    # print(orders)
    # print(order_details)

    # export_manager(person_list, export_as='csv')
    # export_manager(orders, export_as='csv')
    # export_manager(order_details, export_as='csv')
    # dataset = get_dataset(dataset='default', category='Animals & Pet Supplies')
    # print(dataset)
    # dataset = dataset.drop(['Currency'], axis=1)
    # export_manager(dataset, export_as='csv')




    df = pd.read_csv('Data/products.csv')

    column_name = 'Product'

    df['len'] = df[column_name].apply(lambda x: len(str(x)))
    print(sum(df['len']))
